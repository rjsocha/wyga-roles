---
- name: "Process allow/any ..."
  set_fact:
    fwrules: "{{ fwrules + [ { 'any': 'any' } ] }}"
    rule_parsed: true
  when: rule.allow == 'any'

- name: "Process allow/registry-mirror ..."
  set_fact:
    fwrules: "{{ fwrules + fwrule_icmp }}"
    rule_parsed: true
  vars:
    fwrule_icmp:
      - { 'dport': '80', 'match': 'tcp', 'proto': 'tcp', 'dst': [ '100.100.100.100' ] }
  when: rule.allow == 'registry-mirror' or rule.allow == 'registry/mirror'

- name: "Process allow/icmp ..."
  set_fact:
    fwrules: "{{ fwrules + fwrule_icmp }}"
    rule_parsed: true
  vars:
    fwrule_icmp:
      - { 'icmptype': 'destination-unreachable', 'match': 'icmp', 'proto': 'icmp' }
      - { 'icmptype': 'echo-request', 'match': 'icmp', 'proto': 'icmp' }
      - { 'icmptype': 'time-exceeded', 'match': 'icmp', 'proto': 'icmp' }
      - { 'icmptype': 'parameter-problem', 'match': 'icmp', 'proto': 'icmp' }
  when: rule.allow == 'icmp'

- name: "Process allow/http ..."
  set_fact:
    fwrules: "{{ fwrules + fwrule_http }}"
    rule_parsed: true
  vars:
    fwrule_http:
      - { 'dport': '80', 'match': 'tcp', 'proto': 'tcp' }
      - { 'dport': '443', 'match': 'tcp', 'proto': 'tcp' }
      - { 'dport': '443', 'match': 'udp', 'proto': 'udp' }
  when: rule.allow == 'http'

- name: "Process allow/nebula ..."
  block:
    - name: "Append allow/nebula rules ..."
      set_fact:
        fwrule_nebula:
          - { 'dport': '4242', 'match': 'udp', 'proto': 'udp' }
    - name: "Append rule ..."
      set_fact:
        fwrules: "{{ fwrules + fwrule_nebula }}"
        rule_parsed: true
  when: rule.allow == 'nebula'

- name: "Process allow/if ..."
  set_fact:
    fwrules: "{{ fwrules + [{'iface': allow_iface}] }}"
    rule_parsed: true
  vars:
    allow_iface: "{{ rule.allow.split('/')[1] }}"
  when: rule.allow is regex('(?i)^if/[a-z][a-z0-9-]{1,18}[a-z0-9]$')

- name: "Process allow/port/proto/if ..."
  set_fact:
    fwrules: "{{ fwrules + [ { 'proto': allow_proto, 'iface': allow_iface, 'dport': allow_port } ] }}"
    rule_parsed: true
  vars:
    allow_port: "{{ rule.allow.split('/')[0] }}"
    allow_proto: "{{ rule.allow.split('/')[1] }}"
    allow_iface: "{{ rule.allow.split('/')[2] }}"
  when: rule.allow is regex('(?i)^[0-9]+/[a-z]+/([a-z][a-z0-9-]{1,18}[a-z0-9]|[a-z][a-z0-9]+\+)$')

- name: "Process allow/vpn ..."
  block:
    - name: "Append allow/vpn rules ..."
      set_fact:
        fwrule_vpn:
          - { 'iface': 'overlay0' }
          - { 'dport': '4242', 'match': 'udp', 'proto': 'udp' }
    - name: "Append rule ..."
      set_fact:
        fwrules: "{{ fwrules + fwrule_vpn }}"
        rule_parsed: true
  when: rule.allow == 'vpn'

- name: "Process allow/ssh ..."
  block:
    - name: "Extract config name ..."
      set_fact:
        ssh_firewall_file: "{{ rule.allow | split('/') | last | lower }}"
      when: rule.allow is regex('(?i)^ssh/[a-z][a-z0-9-]{1,18}[a-z0-9]$')

    - name: "Select 'any' config name ..."
      set_fact:
        ssh_firewall_file: "any"
      when: rule.allow is regex('(?i)^ssh$')

    - name: "Load ssh hosts ..."
      include_vars:
        file: "site/{{ host_policy_site }}/firewall/ssh/{{ ssh_firewall_file }}"
        name: ssh_firewall_hosts
      when: ssh_firewall_file != 'any'

    - name: "Define 'any' ..."
      set_fact:
        ssh_firewall_hosts:
          hosts:
            - 0.0.0.0/0
      when: ssh_firewall_file == 'any'

    - name: "ERROR ..."
      fail:
      when: ssh_firewall_hosts.hosts is not defined

    - name: "Append rule ..."
      set_fact:
        fwrules: "{{ fwrules + [ { 'match': 'tcp', 'proto': 'tcp', 'src': ssh_firewall_hosts.hosts, 'dport': 22 } ] }}"
        rule_parsed: true
  when: rule.allow is regex('(?i)^ssh/[a-z][a-z0-9-]{1,18}[a-z0-9]$') or rule.allow is regex('(?i)^ssh$')
